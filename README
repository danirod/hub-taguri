hub-taguri

NAME
    hub-taguri - a library for parsing, validating and minting Tag URIs


DESCRIPTION
    hub-taguri is a library that is able to parse, validate and mint Tag URIs
    in conformance with the RFC 4151, "The 'tag' URI Scheme".  These tags are
    identifiers designed to be unique across space and time, while being easy
    to understand by humans.


USAGE
    The `taguri` package exposes a facade with two classes: TagUriMinter and
    TagUriParser.  The first class can be used to mint new tags providing
    the properties.  The second class can be used to extract the properties of
    an already existing tag.  Both classes will validate the given inputs and
    raise AttributeError when appropiate if an input value cannot be validated.

    To mint a new tag, use the TagUriMinter:

        >>> from taguri import TagUriMinter
        >>> minter = TagUriMinter('example.com', '2017')
        >>> minter.mint('path/to/resource.html')
        'tag:example.com,2017:path/to/resource.html'
    
    The TagUriMinter __init__ method accepts two parameters: the authority name
    for the tagging entity, and the date.  Use the mint method to mint a new
    tag providing the specific part of the tag, and optionally the fragment.

        >>> from taguri import TagUriMinter
        >>> minter = TagUriMinter('example.com', '2017')
        >>> minter.mint('Collections.Books', '#Frankenstein')
        'tag:example.com,2017:Collections.Books#Frankenstein'
    
    The authority name can either be a DNS name, or an e-mail address. Note that
    FQDNs are just a subset of the valid DNS names.  For example, unqualified
    DNS names with no dots, such as the ones used in Microsoft Windows networks,
    are valid authority names:

        >>> from taguri import TagUriMinter
        >>> minter = TagUriMinter('Windows-PC', '2018-12-21')
        >>> minter.mint('C:/Users/JohnDoe/Memoir.pdf')
        'tag:Windows-PC,2018-12-21:C:/Users/JohnDoe/Memoir.pdf'
    
    E-mail addresses that are not valid according to the e-mail RFC may be valid
    according to the validators used in this library.  However, these invalid
    e-mail addresses should not be used anyway, as most e-mail servers will
    reject these addresses, so it cannot be prooved the ownership of the
    e-mail address by the tagging entity.

    To parse existing tags, use the TagUriParser.  It accepts the string
    representation of a tag URI, and exposes the internal properties of the
    tag through Python properties.

        >>> from taguri import TagUriParser
        >>> parser = TagUriParser('tag:alice.example.com,2018:Documents#Memoir')
        >>> parser.authority_name
        'alice.example.com'
        >>> parser.date
        '2018'
        >>> parser.specific
        'Documents'
        >>> parser.fragment
        'Memoir'


SPECIFICATION
    This document does not cover the history about Tag URIs.  You can find that
    online.  Also, I'll only describe here the most important parts.  If you
    want to read the whole spec, you can have it online at RFC 4151 [1].

    Under the tag URI scheme, tags are uniform resource identifiers that convey
    enough information to be used as identifiers of entities in an unique
    fashion, while being easy enough to understand the rules to make it possible
    for humans to understand and create new tag URIs.

    As an example, the author quotes GUIDs, UUIDs and OIDs as examples of other
    alternate identifiers that, while can also guarantee some kind of uniqueness
    among time and space, are hard enough to mint or understand to be easily
    used by humans.

    The ABNF grammar for tag URIs is available in the RFC document.  Here is an
    abstract about how those tags are composed.  A tag URI is made of the
    following tokens:

        "tag" : taggingEntity ":" specific [ "#" fragment ]
    
        o The taggingEntity is the entity that generated the tag.  There are no
          rules in the RFC on whether the taggingEntity should stay constant
          through all the tags generated by the same entity.
    
        o The specific identifies the resource among all the tags generated by
          the same tagging entity.  There is no standard procedure on the
          semantics for specific parts of tags, so these are at the mercy of the
          tagging entity.
    
        o Fragments can be used to subidentify resources, just like fragments
          can be used in URLs to identify specific portions of a resource.
    
    The tagging entity is composed of an authority name and a date.

        authorityName "," date
    
    An authority name can be, either a domain name, or an e-mail address.
    This has be done purposely to limit the namespaces that can be used for
    authorityNames, leaving outside namespaces such as IP addresses or telephone
    numbers. Future revisions of the standard may allow this, so it's not
    recommended to make strict validators that reject stuff that does not look
    like a domain name or an e-mail address, to make them future-proof.

    Dates are based on the RFC 3339 (which is at the same time a profile of the
    ISO 8601). They can either be:

        o YYYY-MM-DD, such as 2018-04-21.
        o YYYY-MM, such as 2018-05.  DD is assumed to be 01.
        o YYYY, such as 2018.  MM and DD are assumed to be 01.
    
    By using a tagging entity when minting tags, the creators of a tag URI
    guarantee that the authority name was assigned to them at the given date.
    Some examples:

        o alice.example.org,2015-05-05  conveys that, as of 2015-05-05, the
          creator of a tag URI using this taggingEntity owned the
          alice.example.org FQDN at that time.
        
        o johndoe@example.org,2016 conveys that, as of 2016-01-01, the creator
          of a tag URI using this taggingEntity owned the e-mail address
          johndoe@example.org.
    
    Some additional rules on the dates used in tagging entities:

        o There are no time components in a date.  Time is always assumed to
          be 00:00 UTC.  This should only be remembered if tagging tagging
          entities include a date, but is safe to ignore otherwise.
        
        o Two timestamps omitting different parts of the date component are
          not the same, even when after normalizing them they would look the
          same.  2018-05 and 2018-05-01 are not the same dates when used
          in a tag URL.  2018 and 2018-01-01 are also not the same.
    
    Some additional semantics about tagging entities:

        o An entity may not use for a tagging entity, a date that is before
          the date the authority name was assigned to them.  So if Alice
          is assigned alice.example.org at 2014-04-20, she should not mint
          tag URIs using alice.example.org,2014 or alice.example.org,2014-04.
        
        o Because of this, an entity may not use a future date as part of the
          tagging entity.  Authors of the spec propose hp.com,2999 as an
          example of a tagging entity that should not be used.
        
    If the authority name and date is correctly formulated, there is a
    guarantee that two different entities may not mint tag URIs under the same
    taggingEntity.


WHY NOT JUST USING AN URL
    Another example are URL identifiers.  These are easy enough to mint, and
    they are unique among space: if Alice owns the alice.example.org domain,
    Bob cannot use an URL such as http://alice.example.org/bob as an identifier
    unless he's a co-owner of alice.example.org domain. However, URL identifiers
    are not unique among time, as domains can expire, be transfered, or change
    owner.
    
    Additionally, using URLs as identifiers may set an expectation about whether
    the given URL ID should resolve to a valid document when used in a web
    browser.  For identifiers or electronic documents served through the HTTP or
    HTTPS protocol, this might be a valid case. For example,
    http://blog.example.org/2018/05/my-blog-post could be the identifier of a
    blog post named "My blog post", which happens to resolve to an HTML document
    with the contents of the blog post when the URLs is accessed using the HTTP
    protocol, and the HTTP 'Accept' header is set to include the text/html
    MIME type.  However, if a personal and private address book uses URLs to
    identify contacts, http://example.org/contacts/John_Doe could be the
    identifier of a contact, but it might not resolve to a valid document when
    accessed using the HTTP protocol.

    Finally, and most important, using URLs as identifiers assumes that the
    creator of the identifier owns a domain name that can be used as a namespace
    for minted URLs, which may or may not be the case.  Tag URIs can be minted
    using e-mail addresses as an alternative, which may be easy to own under
    some circumstances.


AUTHORS
    Dani Rodríguez <dani@danirod.es>


LICENSE
    Copyright (c) 2018 Dani Rodríguez <dani@danirod.es>

    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"), to
    deal in the Software without restriction, including without limitation the
    rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
    sell copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in
    all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
    SOFTWARE.


REFERENCES
    [1]     Kindberg, T., "The 'tag' URI Scheme", IETF, October 2005.
            URL: https://tools.ietf.org/html/rfc4151

